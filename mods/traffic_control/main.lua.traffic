--[[
       使用openresty实现基于uri的限流功能
       nginx配置: 
       http {
           lua_shared_dict uri_limit_map 10m;
           lua_shared_dict qps_limit_store 10m;
       }
       author: frank chen
--]]
local limit_req = require "resty.limit.req"
local limit_traffic = require "resty.limit.traffic"
local base = require "access_control.mods.base"
local common_cfg = require "access_control.config"
local logger = require "access_control.utils.logger"
logger.mod_name = "traffic_control"

local limiter_list = {}
local uri_list = {}
local states = {}

local redis_key_prefix = "traffic_limit"
local cache_file_path = common_cfg.cache_file_basepath .. "traffic_limit_setting.json"

local _M = {}
setmetatable(_M, {__index = base})

--[[
       为uri创建limit_req
--]]
local function new_limit_req(uri, qps_limit, burst)
    -- 限制uri的QPS为qps_limit并允许突发QPS为$burst，即如果qps_limit < QPS < qps_limit + burst，则delay处理，如果QPS > $qps_limit + $burst，则直接拒绝请求
    local result, err = limit_req.new("qps_limit_store", qps_limit, burst)
    if not result then
        logger:err("failed to instantiate a resty.limit.req object: " .. err .. ", uri: " .. uri)
        return nil
    end
    return result
end


--[[
       redis同步配置回调
--]]
function _M.on_sync(self)
    logger:info("Begin update traffic limiting config")

    -- 从redis或缓存文件读取数据
    local config_list = self:fetch_data(redis_key_prefix, cache_file_path)

    -- 更新共享内存
    if config_list == nil or next(config_list) == nil then
        logger:warn("NO CONFIG DATA FOUND FROM REDIS OR CACHE FILE")
        return
    end

    limiter_list = {}
    uri_list = {}
    for k, v in pairs(config_list) do
        local qps_limit = tonumber(v)
        if qps_limit ~= nil then
            local burst = qps_limit * 0.1
            local limiter = new_limit_req(k, qps_limit, burst)
            if limiter ~= nil then
                table.insert(limiter_list, limiter)
                table.insert(uri_list, k)
            end
        else
            logger:warn("NON-NUMBER VALUE " .. v .. " FOR KEY " .. k)
        end
    end

    logger:info("End update traffic limiting config"..uri_list[1])
end


--[[
       核心函数，对uri实行限流
--]]
function _M.on_filter(self)
    local uri = ngx.var.uri
    if uri_list[uri] == nil then
        return
    end

    local delay, err = limit_traffic:combine(limiter_list, uri_list, states)
    if not delay then
        if err == "rejected" then
            -- where the throttling goes
            return ngx.exit(503)
        end
        logger:err("failed to limit traffic: " .. err.." uri: ".. uri)
        return ngx.exit(500)
    end

    if delay >= 0.001 then
        -- 当 $qps_limit < QPS < qps_limit + $burst时, 为了保持QPS == $qps_limit，这里delay一段时间
        logger:debug("delay it here a bit to conform to the connection limit, time: " .. delay)
        ngx.sleep(delay)
    end
end

return _M
